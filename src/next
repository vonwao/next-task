#!/bin/bash
# next - Task queue runner for AI coding agents
# https://github.com/vonwao/next-task

# Note: Not using set -e because grep/sed return non-zero on no-match,
# which would cause spurious exits. We handle errors explicitly.

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
NC='\033[0m'

PROJECT_DIR="$(pwd)"
PROJECT_NAME="$(basename "$PROJECT_DIR")"
TASKS_FILE="$PROJECT_DIR/TASKS.md"
AGENT_FILE="$PROJECT_DIR/AGENT.md"
CONFIG_FILE="$PROJECT_DIR/.agent/config.yml"

# Default config
DEFAULT_AGENT="codex"
YOLO=true
VALIDATE_CMD=""

# Load config if exists
load_config() {
  if [ -f "$CONFIG_FILE" ]; then
    DEFAULT_AGENT=$(grep -E '^agent:' "$CONFIG_FILE" 2>/dev/null | awk '{print $2}' | cut -d'#' -f1 | tr -d ' ' || echo "codex")
    YOLO_CFG=$(grep -E '^yolo:' "$CONFIG_FILE" 2>/dev/null | awk '{print $2}' | cut -d'#' -f1 | tr -d ' ' || echo "true")
    VALIDATE_CMD=$(grep -E '^validate:' "$CONFIG_FILE" 2>/dev/null | sed 's/^validate:[ ]*//' | cut -d'#' -f1 | sed 's/[ ]*$//' || echo "")
    [ "$YOLO_CFG" = "false" ] && YOLO=false
    [ "$DEFAULT_AGENT" = "" ] && DEFAULT_AGENT="codex"
  fi
}

# Get all done task IDs
get_done_tasks() {
  grep -E '^### T[0-9a-zA-Z_-]+:.*‚úÖ' "$TASKS_FILE" 2>/dev/null | \
    sed -E 's/^### (T[0-9a-zA-Z_-]+):.*/\1/' || true
}

# Check if all dependencies are met
deps_met() {
  local deps="$1"
  local done_tasks=$(get_done_tasks)
  
  if [ -z "$deps" ] || [ "$deps" = "(none)" ]; then
    return 0
  fi
  
  # Split deps by comma and check each
  IFS=',' read -ra DEP_ARRAY <<< "$deps"
  for dep in "${DEP_ARRAY[@]}"; do
    dep=$(echo "$dep" | tr -d ' ')
    if ! echo "$done_tasks" | grep -q "^${dep}$"; then
      return 1
    fi
  done
  return 0
}

# Parse a task block and extract metadata
parse_task() {
  local task_header="$1"
  local task_body="$2"
  
  # Extract task ID: ### T1: or ### task-name:
  TASK_ID=$(echo "$task_header" | sed -E 's/^### (T[0-9a-zA-Z_-]+|[a-z][a-z0-9_-]+):.*/\1/')
  
  # Extract agent from @claude or @codex tag
  if echo "$task_header" | grep -q '@claude'; then
    TASK_AGENT="claude"
  elif echo "$task_header" | grep -q '@codex'; then
    TASK_AGENT="codex"
  else
    TASK_AGENT="$DEFAULT_AGENT"
  fi
  
  # Check for flags (use if/then to avoid set -e issues)
  if echo "$task_header" | grep -q '\[use-subagents\]'; then
    TASK_USE_SUBAGENTS="true"
  else
    TASK_USE_SUBAGENTS="false"
  fi
  if echo "$task_header" | grep -q '\[research\]'; then
    TASK_RESEARCH="true"
  else
    TASK_RESEARCH="false"
  fi
  if echo "$task_header" | grep -q '\[manual\]'; then
    TASK_MANUAL="true"
  else
    TASK_MANUAL="false"
  fi
  
  # Extract title (everything between ID: and @agent or flags)
  TASK_TITLE=$(echo "$task_header" | sed -E 's/^### T[0-9a-zA-Z_-]+: //' | sed -E 's/ @(claude|codex).*//' | sed -E 's/ \[.*//')
  
  # Extract metadata from body (use head -1 to get only first match, || true for missing)
  TASK_DEPENDS=$(echo "$task_body" | grep -E '^\*\*Depends:\*\*' | head -1 | sed 's/\*\*Depends:\*\* //' || true)
  TASK_ARTIFACTS=$(echo "$task_body" | grep -E '^\*\*Artifacts:\*\*' | head -1 | sed 's/\*\*Artifacts:\*\* //' || true)
  TASK_COMMIT=$(echo "$task_body" | grep -E '^\*\*Commit:\*\*' | head -1 | sed 's/\*\*Commit:\*\* //' | tr -d '`' || true)
  
  # Extract description (everything except metadata lines)
  TASK_DESC=$(echo "$task_body" | grep -v -E '^\*\*(Depends|Artifacts|Commit|Started|Parallel):\*\*' | sed '/^$/d')
}

# Find next ready task
find_next_task() {
  local in_milestone=""
  local found_task=""
  local task_header=""
  local task_body=""
  local collecting_body=false
  
  while IFS= read -r line; do
    # Track milestones
    if echo "$line" | grep -qE '^## üèÅ'; then
      in_milestone=$(echo "$line" | sed 's/## üèÅ Milestone [0-9]*: //')
    fi
    
    # Skip Done and In Progress sections
    if echo "$line" | grep -qE '^## (Done|In Progress)'; then
      break
    fi
    
    # Found a task header
    if echo "$line" | grep -qE '^### T[0-9a-zA-Z_-]+:'; then
      # If we were collecting a previous task, check if it's ready
      if [ -n "$task_header" ]; then
        parse_task "$task_header" "$task_body"
        if [ "$TASK_MANUAL" = "false" ] && deps_met "$TASK_DEPENDS"; then
          found_task="$task_header"
          break
        fi
      fi
      
      task_header="$line"
      task_body=""
      collecting_body=true
    elif [ "$collecting_body" = true ]; then
      # Stop at next task or section
      if echo "$line" | grep -qE '^##'; then
        # Check last collected task
        if [ -n "$task_header" ]; then
          parse_task "$task_header" "$task_body"
          if [ "$TASK_MANUAL" = "false" ] && deps_met "$TASK_DEPENDS"; then
            found_task="$task_header"
            break
          fi
        fi
        task_header=""
        collecting_body=false
      else
        task_body="$task_body"$'\n'"$line"
      fi
    fi
  done < "$TASKS_FILE"
  
  # Check last task if we haven't found one yet
  if [ -z "$found_task" ] && [ -n "$task_header" ]; then
    parse_task "$task_header" "$task_body"
    if [ "$TASK_MANUAL" = "false" ] && deps_met "$TASK_DEPENDS"; then
      found_task="$task_header"
    fi
  fi
  
  echo "$found_task"
}

# Get task currently in progress
get_in_progress() {
  sed -n '/^## In Progress/,/^## /p' "$TASKS_FILE" 2>/dev/null | \
    grep -E '^### T[0-9a-zA-Z_-]+:' | head -1 || true
}

# Build prompt for agent
build_prompt() {
  local prompt=""
  
  prompt="# Task: $TASK_TITLE

$TASK_DESC"
  
  if [ -n "$TASK_ARTIFACTS" ]; then
    prompt="$prompt

## Expected Artifacts
$TASK_ARTIFACTS"
  fi
  
  if [ -n "$TASK_COMMIT" ]; then
    prompt="$prompt

## When Complete
Commit your changes with: \`$TASK_COMMIT\`"
  fi
  
  if [ "$TASK_USE_SUBAGENTS" = "true" ]; then
    prompt="$prompt

## Parallelization
This task can be parallelized. Use sub-agents for independent pieces of work."
  fi
  
  echo "$prompt"
}

# Run the agent
run_agent() {
  local prompt="$1"
  
  if [ "$TASK_AGENT" = "codex" ]; then
    # Use 'codex exec' for non-interactive mode
    CMD="codex exec"
    $YOLO && CMD="$CMD --full-auto"
    
    # Codex: write combined prompt with context
    TEMP_PROMPT=$(mktemp)
    if [ -f "$AGENT_FILE" ]; then
      cat "$AGENT_FILE" > "$TEMP_PROMPT"
      echo -e "\n---\n" >> "$TEMP_PROMPT"
    fi
    echo "$prompt" >> "$TEMP_PROMPT"
    
    echo -e "${MAGENTA}‚ñ∂ Running Codex (non-interactive)${NC}"
    echo ""
    $CMD "$(cat "$TEMP_PROMPT")"
    rm -f "$TEMP_PROMPT"
    
  else
    CMD="claude"
    $YOLO && CMD="$CMD --dangerously-skip-permissions"
    
    # Claude: ensure AGENT.md is symlinked to CLAUDE.md
    if [ -f "$AGENT_FILE" ] && [ ! -f "$PROJECT_DIR/CLAUDE.md" ]; then
      ln -sf AGENT.md "$PROJECT_DIR/CLAUDE.md"
      CREATED_SYMLINK=true
    fi
    
    echo -e "${MAGENTA}‚ñ∂ Running Claude Code${NC}"
    echo ""
    $CMD "$prompt"
    
    [ "$CREATED_SYMLINK" = "true" ] && rm -f "$PROJECT_DIR/CLAUDE.md"
  fi
}

# Move task to In Progress
move_to_in_progress() {
  local task_header="$1"
  local timestamp=$(date '+%Y-%m-%d %H:%M')
  
  # Remove task from current location (including following lines until next ### or ##)
  # This is tricky in bash, using a temp file approach
  local temp_file=$(mktemp)
  local skip_until_next=false
  local task_pattern=$(echo "$task_header" | sed 's/[[\.*^$()+?{|]/\\&/g')
  
  while IFS= read -r line; do
    if echo "$line" | grep -qF "$task_header"; then
      skip_until_next=true
      continue
    fi
    if [ "$skip_until_next" = true ]; then
      if echo "$line" | grep -qE '^###|^##'; then
        skip_until_next=false
        echo "$line" >> "$temp_file"
      fi
      continue
    fi
    echo "$line" >> "$temp_file"
  done < "$TASKS_FILE"
  
  mv "$temp_file" "$TASKS_FILE"
  
  # Add to In Progress section with timestamp
  local in_progress_content="$task_header
**Started:** $timestamp
"
  
  # Insert after ## In Progress
  sed -i '' "/^## In Progress/a\\
\\
$task_header\\
**Started:** $timestamp
" "$TASKS_FILE"
}

# Mark current task as done
mark_done() {
  local in_progress=$(get_in_progress)
  
  if [ -z "$in_progress" ]; then
    echo -e "${YELLOW}No task in progress${NC}"
    exit 1
  fi
  
  # Parse to get metadata
  local task_body=$(sed -n "/^## In Progress/,/^## /p" "$TASKS_FILE" | tail -n +2 | sed '/^## /d')
  parse_task "$in_progress" "$task_body"
  
  local timestamp=$(date '+%Y-%m-%d')
  local commit_hash=""
  
  # Run validation if configured
  if [ -n "$VALIDATE_CMD" ]; then
    echo -e "${BLUE}Running validation:${NC} $VALIDATE_CMD"
    if ! eval "$VALIDATE_CMD"; then
      echo -e "${RED}Validation failed. Fix issues before marking done.${NC}"
      exit 1
    fi
    echo -e "${GREEN}Validation passed${NC}"
  fi
  
  # Commit if specified
  if [ -n "$TASK_COMMIT" ]; then
    echo -e "${BLUE}Committing:${NC} $TASK_COMMIT"
    git add -A
    git commit -m "$TASK_COMMIT" || true
    commit_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "")
  fi
  
  # Remove from In Progress
  local temp_file=$(mktemp)
  local skip_until_next=false
  
  while IFS= read -r line; do
    if echo "$line" | grep -qE '^## In Progress'; then
      echo "$line" >> "$temp_file"
      skip_until_next=true
      continue
    fi
    if [ "$skip_until_next" = true ]; then
      if echo "$line" | grep -qE '^## '; then
        skip_until_next=false
        echo "$line" >> "$temp_file"
      fi
      continue
    fi
    echo "$line" >> "$temp_file"
  done < "$TASKS_FILE"
  
  mv "$temp_file" "$TASKS_FILE"
  
  # Add to Done section
  local done_entry="### $TASK_ID: $TASK_TITLE @$TASK_AGENT ‚úÖ"
  [ -n "$commit_hash" ] && done_entry="$done_entry
**Completed:** $timestamp | Commit: $commit_hash" || done_entry="$done_entry
**Completed:** $timestamp"
  
  sed -i '' "/^## Done/a\\
\\
$done_entry
" "$TASKS_FILE"
  
  echo -e "${GREEN}‚úÖ Completed:${NC} $TASK_TITLE"
  
  # Log to CTO task-log if available
  if [ -x "$HOME/clawd/scripts/task-log.sh" ]; then
    "$HOME/clawd/scripts/task-log.sh" "$PROJECT_NAME" "$TASK_TITLE" done "agent-runner,$TASK_AGENT" "$commit_hash" 2>/dev/null && \
      echo -e "${CYAN}üìù Logged to task-log${NC}"
  fi
  
  # Show what's next
  echo ""
  show_status
}

# Show status
show_status() {
  echo -e "${BOLD}Project:${NC} $PROJECT_NAME"
  echo -e "${BOLD}Default agent:${NC} $DEFAULT_AGENT"
  echo ""
  
  # In Progress
  local in_progress=$(get_in_progress)
  if [ -n "$in_progress" ]; then
    parse_task "$in_progress" ""
    echo -e "${YELLOW}‚ñ∂ In Progress:${NC} $TASK_TITLE ${CYAN}@$TASK_AGENT${NC}"
  else
    echo -e "${YELLOW}‚ñ∂ In Progress:${NC} (none)"
  fi
  echo ""
  
  # Ready tasks
  echo -e "${GREEN}Ready:${NC}"
  local found_ready=false
  local done_tasks=$(get_done_tasks)
  
  # Use process substitution to avoid subshell (so found_ready persists)
  while read -r line; do
    # Skip if in Done section
    if sed -n '/^## Done/,$ p' "$TASKS_FILE" | grep -qF "$line"; then
      continue
    fi
    # Skip if in In Progress section  
    if sed -n '/^## In Progress/,/^## / p' "$TASKS_FILE" | grep -qF "$line"; then
      continue
    fi
    
    # Parse and check deps - extract body until next ### or ## line
    task_body=""
    in_task=false
    while IFS= read -r bodyline; do
      if [ "$bodyline" = "$line" ]; then
        in_task=true
        continue
      fi
      if [ "$in_task" = true ]; then
        # Stop at next task or section header
        if echo "$bodyline" | grep -qE '^### |^## '; then
          break
        fi
        task_body="${task_body}${bodyline}"$'\n'
      fi
    done < "$TASKS_FILE"
    parse_task "$line" "$task_body"
    
    if deps_met "$TASK_DEPENDS"; then
      echo -e "  ‚Ä¢ $TASK_TITLE ${CYAN}@$TASK_AGENT${NC}"
      found_ready=true
    fi
  done < <(grep -E '^### T[0-9a-zA-Z_-]+:' "$TASKS_FILE" 2>/dev/null)
  
  [ "$found_ready" = false ] && echo "  (none ready - check dependencies)"
  echo ""
  
  # Done count
  local done_count=$(grep -cE '^### T[0-9a-zA-Z_-]+:.*‚úÖ' "$TASKS_FILE" 2>/dev/null || echo "0")
  echo -e "${BLUE}Done:${NC} $done_count tasks"
}

# Main
load_config

case "${1:-run}" in
  init)
    mkdir -p "$PROJECT_DIR/.agent"
    
    if [ ! -f "$TASKS_FILE" ]; then
      cat > "$TASKS_FILE" << 'EOF'
# Tasks

## üèÅ Milestone 1: MVP

### T1: First task @codex
**Depends:** (none)
**Artifacts:** src/example.ts
**Commit:** `feat: first feature`

Describe what needs to be done here.

---
üéØ **Milestone 1 complete:** Description of what's achieved

## In Progress

## Done

EOF
      echo -e "${GREEN}Created TASKS.md${NC}"
    fi
    
    if [ ! -f "$AGENT_FILE" ]; then
      cat > "$AGENT_FILE" << EOF
# $PROJECT_NAME

Project description here.

## Task Completion Protocol

Before marking any task as complete:
1. Ensure all artifacts exist
2. Run validation (if configured)
3. Commit with the specified message

## Project Structure

Describe key directories and files.

## Conventions

Describe coding conventions.
EOF
      echo -e "${GREEN}Created AGENT.md${NC}"
    fi
    
    if [ ! -f "$CONFIG_FILE" ]; then
      cat > "$CONFIG_FILE" << 'EOF'
# Agent configuration
agent: codex         # Default agent (claude or codex)
yolo: true           # Skip confirmation prompts
validate:            # Command to run before marking done (e.g., pnpm test)
EOF
      echo -e "${GREEN}Created .agent/config.yml${NC}"
    fi
    
    echo -e "${BLUE}Project initialized for next-task${NC}"
    ;;
    
  status|s)
    show_status
    ;;
    
  list|l)
    cat "$TASKS_FILE"
    ;;
    
  done|d)
    mark_done
    ;;
    
  add|a)
    shift
    if [ $# -lt 1 ]; then
      echo "Usage: next add <task description> [@agent]"
      exit 1
    fi
    
    # Find highest task number
    last_num=$(grep -oE '^### T([0-9]+):' "$TASKS_FILE" | grep -oE '[0-9]+' | sort -n | tail -1 || echo "0")
    new_num=$((last_num + 1))
    
    task_desc="$*"
    agent_tag="@codex"
    if echo "$task_desc" | grep -q '@claude'; then
      agent_tag="@claude"
      task_desc=$(echo "$task_desc" | sed 's/ *@claude//')
    elif echo "$task_desc" | grep -q '@codex'; then
      agent_tag="@codex"
      task_desc=$(echo "$task_desc" | sed 's/ *@codex//')
    fi
    
    # Add before ## In Progress
    sed -i '' "/^## In Progress/i\\
\\
### T$new_num: $task_desc $agent_tag\\
**Depends:** (none)\\
**Artifacts:** \\
**Commit:** \`feat: \`\\
\\
" "$TASKS_FILE"
    
    echo -e "${GREEN}Added:${NC} T$new_num: $task_desc $agent_tag"
    ;;
    
  run|"")
    # Check for in-progress task
    in_progress=$(get_in_progress)
    if [ -n "$in_progress" ]; then
      parse_task "$in_progress" ""
      echo -e "${YELLOW}Task already in progress:${NC} $TASK_TITLE"
      echo "Run 'next done' to complete it, or 'next skip' to skip."
      exit 1
    fi
    
    # Find next ready task
    next_task=$(find_next_task)
    
    if [ -z "$next_task" ]; then
      echo -e "${GREEN}üéâ All tasks complete!${NC}"
      show_status
      exit 0
    fi
    
    # Parse the task
    task_body=$(sed -n "/$(echo "$next_task" | sed 's/[[\.*^$()+?{|]/\\&/g')/,/^###\\|^##/p" "$TASKS_FILE" | tail -n +2 | sed '/^###\|^##/d')
    parse_task "$next_task" "$task_body"
    
    echo -e "${BOLD}Next task:${NC} $TASK_TITLE"
    echo -e "${BOLD}Agent:${NC} $TASK_AGENT"
    [ -n "$TASK_ARTIFACTS" ] && echo -e "${BOLD}Artifacts:${NC} $TASK_ARTIFACTS"
    [ -n "$TASK_COMMIT" ] && echo -e "${BOLD}Commit:${NC} $TASK_COMMIT"
    echo ""
    
    # Move to in progress
    move_to_in_progress "$next_task"
    
    # Build prompt and run
    prompt=$(build_prompt)
    run_agent "$prompt"
    
    echo ""
    echo -e "${GREEN}Agent finished.${NC}"
    
    # Auto-commit if commit message specified
    commit_hash=""
    if [ -n "$TASK_COMMIT" ]; then
      echo ""
      echo -e "${BLUE}Auto-committing:${NC} $TASK_COMMIT"
      git add -A
      if git commit -m "$TASK_COMMIT"; then
        commit_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "")
        echo -e "${GREEN}‚úÖ Committed ($commit_hash)${NC}"
      else
        echo -e "${YELLOW}No changes to commit${NC}"
      fi
    fi
    
    # Auto-mark task as done
    echo ""
    echo -e "${BLUE}Marking task complete...${NC}"
    timestamp=$(date '+%Y-%m-%d')
    
    # Remove from In Progress section
    temp_file=$(mktemp)
    skip_section=false
    while IFS= read -r line; do
      if echo "$line" | grep -qE '^## In Progress'; then
        echo "$line" >> "$temp_file"
        echo "" >> "$temp_file"
        skip_section=true
        continue
      fi
      if [ "$skip_section" = true ]; then
        if echo "$line" | grep -qE '^## '; then
          skip_section=false
          echo "$line" >> "$temp_file"
        fi
        continue
      fi
      echo "$line" >> "$temp_file"
    done < "$TASKS_FILE"
    mv "$temp_file" "$TASKS_FILE"
    
    # Add to Done section (portable method - no sed -i issues)
    temp_file=$(mktemp)
    done_written=false
    while IFS= read -r line; do
      echo "$line" >> "$temp_file"
      if [ "$done_written" = false ] && echo "$line" | grep -qE '^## Done'; then
        echo "" >> "$temp_file"
        echo "### $TASK_ID: $TASK_TITLE @$TASK_AGENT ‚úÖ" >> "$temp_file"
        if [ -n "$commit_hash" ]; then
          echo "**Completed:** $timestamp | Commit: $commit_hash" >> "$temp_file"
        else
          echo "**Completed:** $timestamp" >> "$temp_file"
        fi
        done_written=true
      fi
    done < "$TASKS_FILE"
    mv "$temp_file" "$TASKS_FILE"
    
    echo -e "${GREEN}‚úÖ Completed:${NC} $TASK_TITLE"
    
    # Log to CTO task-log if available
    if [ -x "$HOME/clawd/scripts/task-log.sh" ]; then
      "$HOME/clawd/scripts/task-log.sh" "$PROJECT_NAME" "$TASK_TITLE" done "agent-runner,$TASK_AGENT" "$commit_hash" 2>/dev/null && \
        echo -e "${CYAN}üìù Logged to task-log${NC}"
    fi
    
    # Show status
    echo ""
    show_status
    ;;
    
  skip)
    in_progress=$(get_in_progress)
    if [ -z "$in_progress" ]; then
      echo -e "${YELLOW}No task in progress to skip${NC}"
      exit 1
    fi
    
    parse_task "$in_progress" ""
    echo -e "${YELLOW}Skipped:${NC} $TASK_TITLE"
    echo "Task moved back to Ready. Run 'next' to pick up next task."
    
    # For now, just clear In Progress (task is lost - TODO: move to blocked)
    temp_file=$(mktemp)
    skip_until_next=false
    
    while IFS= read -r line; do
      if echo "$line" | grep -qE '^## In Progress'; then
        echo "$line" >> "$temp_file"
        skip_until_next=true
        continue
      fi
      if [ "$skip_until_next" = true ]; then
        if echo "$line" | grep -qE '^## '; then
          skip_until_next=false
          echo "$line" >> "$temp_file"
        fi
        continue
      fi
      echo "$line" >> "$temp_file"
    done < "$TASKS_FILE"
    
    mv "$temp_file" "$TASKS_FILE"
    ;;
    
  help|--help|-h)
    echo "next-task: Task queue runner for AI coding agents"
    echo ""
    echo "Usage: next [command]"
    echo ""
    echo "Commands:"
    echo "  run        Run next ready task (default)"
    echo "  status     Show task status"
    echo "  list       Show full TASKS.md"
    echo "  done       Mark current task complete"
    echo "  add        Add a new task"
    echo "  skip       Skip current task"
    echo "  init       Initialize project"
    echo "  help       Show this help"
    ;;
    
  *)
    echo "Unknown command: $1"
    echo "Run 'next help' for usage"
    exit 1
    ;;
esac
