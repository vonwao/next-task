#!/bin/bash
# next v2 - Task queue runner for AI coding agents
# Major improvements:
# - Separate state file (.agent/state.json) for reliability
# - LOG.md for completion history (append-only)
# - TASKS.md stays clean (mark in-place, don't move tasks)
# - Cleaner prompts (only current task, not all future tasks)

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

PROJECT_DIR="$(pwd)"
PROJECT_NAME="$(basename "$PROJECT_DIR")"
TASKS_FILE="$PROJECT_DIR/TASKS.md"
AGENT_FILE="$PROJECT_DIR/AGENT.md"
CONFIG_FILE="$PROJECT_DIR/.agent/config.yml"
STATE_FILE="$PROJECT_DIR/.agent/state.json"
LOG_FILE="$PROJECT_DIR/LOG.md"

# Default config
DEFAULT_AGENT="codex"
YOLO=true
VALIDATE_CMD=""
NOTIFICATIONS=true

#######################################
# State Management (JSON)
#######################################

# Initialize state file if it doesn't exist
init_state() {
  if [ ! -f "$STATE_FILE" ]; then
    mkdir -p "$(dirname "$STATE_FILE")"
    echo '{"done":[],"inProgress":null,"log":[]}' > "$STATE_FILE"
  fi
}

# Read state using python (more reliable than jq for portability)
read_state() {
  python3 -c "
import json
with open('$STATE_FILE') as f:
    state = json.load(f)
print(json.dumps(state))
" 2>/dev/null || echo '{"done":[],"inProgress":null,"log":[]}'
}

# Get list of done task IDs
get_done_ids() {
  python3 -c "
import json
with open('$STATE_FILE') as f:
    state = json.load(f)
for tid in state.get('done', []):
    print(tid)
" 2>/dev/null
}

# Get in-progress task ID
get_in_progress_id() {
  python3 -c "
import json
with open('$STATE_FILE') as f:
    state = json.load(f)
ip = state.get('inProgress')
if ip:
    print(ip)
" 2>/dev/null
}

# Check if task is done
is_task_done() {
  local task_id="$1"
  python3 -c "
import json
with open('$STATE_FILE') as f:
    state = json.load(f)
exit(0 if '$task_id' in state.get('done', []) else 1)
" 2>/dev/null
}

# Mark task as in progress
set_in_progress() {
  local task_id="$1"
  python3 -c "
import json
with open('$STATE_FILE') as f:
    state = json.load(f)
state['inProgress'] = '$task_id'
with open('$STATE_FILE', 'w') as f:
    json.dump(state, f, indent=2)
" 2>/dev/null
}

# Mark task as done
mark_task_done() {
  local task_id="$1"
  local commit_hash="$2"
  local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  
  python3 -c "
import json
with open('$STATE_FILE') as f:
    state = json.load(f)

# Add to done list if not already there
if '$task_id' not in state.get('done', []):
    state.setdefault('done', []).append('$task_id')

# Clear in-progress
state['inProgress'] = None

# Add to log
state.setdefault('log', []).append({
    'taskId': '$task_id',
    'timestamp': '$timestamp',
    'commit': '$commit_hash' or None
})

with open('$STATE_FILE', 'w') as f:
    json.dump(state, f, indent=2)
" 2>/dev/null
}

# Clear in-progress (for skip)
clear_in_progress() {
  python3 -c "
import json
with open('$STATE_FILE') as f:
    state = json.load(f)
state['inProgress'] = None
with open('$STATE_FILE', 'w') as f:
    json.dump(state, f, indent=2)
" 2>/dev/null
}

#######################################
# LOG.md Management
#######################################

# Append to LOG.md
append_log() {
  local task_id="$1"
  local task_title="$2"
  local commit_hash="$3"
  local timestamp=$(date '+%Y-%m-%d %H:%M')
  local today=$(date '+%Y-%m-%d')
  
  # Create LOG.md if doesn't exist
  if [ ! -f "$LOG_FILE" ]; then
    echo "# Task Log" > "$LOG_FILE"
    echo "" >> "$LOG_FILE"
  fi
  
  # Check if today's header exists
  if ! grep -q "^## $today" "$LOG_FILE"; then
    echo "" >> "$LOG_FILE"
    echo "## $today" >> "$LOG_FILE"
  fi
  
  # Append entry
  if [ -n "$commit_hash" ]; then
    echo "- **$task_id**: $task_title âœ… \`$commit_hash\` @ $timestamp" >> "$LOG_FILE"
  else
    echo "- **$task_id**: $task_title âœ… @ $timestamp" >> "$LOG_FILE"
  fi
}

#######################################
# TASKS.md Parsing
#######################################

# Load config
load_config() {
  if [ -f "$CONFIG_FILE" ]; then
    DEFAULT_AGENT=$(grep -E '^agent:' "$CONFIG_FILE" 2>/dev/null | awk '{print $2}' | cut -d'#' -f1 | tr -d ' ' || echo "codex")
    YOLO_CFG=$(grep -E '^yolo:' "$CONFIG_FILE" 2>/dev/null | awk '{print $2}' | cut -d'#' -f1 | tr -d ' ' || echo "true")
    VALIDATE_CMD=$(grep -E '^validate:' "$CONFIG_FILE" 2>/dev/null | sed 's/^validate:[ ]*//' | cut -d'#' -f1 | sed 's/[ ]*$//' || true)
    NOTIFICATIONS_CFG=$(grep -E '^notifications:' "$CONFIG_FILE" 2>/dev/null | awk '{print $2}' | cut -d'#' -f1 | tr -d ' ' || true)
    [ "$YOLO_CFG" = "false" ] && YOLO=false
    [ -z "$DEFAULT_AGENT" ] && DEFAULT_AGENT="codex"
    if [ -n "$NOTIFICATIONS_CFG" ]; then
      if [ "$NOTIFICATIONS_CFG" = "false" ] || [ "$NOTIFICATIONS_CFG" = "0" ] || [ "$NOTIFICATIONS_CFG" = "no" ]; then
        NOTIFICATIONS=false
      else
        NOTIFICATIONS=true
      fi
    fi
  fi
}

# Send desktop notification (best-effort)
notify() {
  local message="$1"
  local title="${2:-next-task}"
  
  [ "$NOTIFICATIONS" = "false" ] && return 0
  
  local os_name
  os_name=$(uname -s 2>/dev/null || echo "")
  
  if [ "$os_name" = "Darwin" ]; then
    osascript -e "display notification \"$message\" with title \"$title\"" >/dev/null 2>&1
  elif [ "$os_name" = "Linux" ]; then
    if command -v notify-send >/dev/null 2>&1; then
      notify-send "$title" "$message" >/dev/null 2>&1
    fi
  fi
}

# Parse a task from TASKS.md
# Sets: TASK_ID, TASK_TITLE, TASK_AGENT, TASK_DEPENDS, TASK_SPEC, TASK_ARTIFACTS, TASK_COMMIT, TASK_DESC, TASK_FLAGS
parse_task() {
  local task_id="$1"
  
  # Find the task header line
  local header=$(grep -E "^### $task_id:" "$TASKS_FILE" | head -1)
  if [ -z "$header" ]; then
    return 1
  fi
  
  TASK_ID="$task_id"
  
  # Extract agent
  if echo "$header" | grep -q '@claude'; then
    TASK_AGENT="claude"
  elif echo "$header" | grep -q '@codex'; then
    TASK_AGENT="codex"
  else
    TASK_AGENT="$DEFAULT_AGENT"
  fi
  
  # Extract flags
  TASK_FLAGS=""
  echo "$header" | grep -q '\[use-subagents\]' && TASK_FLAGS="$TASK_FLAGS use-subagents"
  echo "$header" | grep -q '\[research\]' && TASK_FLAGS="$TASK_FLAGS research"
  echo "$header" | grep -q '\[manual\]' && TASK_FLAGS="$TASK_FLAGS manual"
  
  # Extract title (between ID: and @agent)
  TASK_TITLE=$(echo "$header" | sed -E 's/^### T[0-9a-zA-Z_-]+: //' | sed -E 's/ @(claude|codex).*//' | sed -E 's/ \[.*//')
  
  # Extract task body (everything between this header and next ### or ##)
  local in_task=false
  local body=""
  while IFS= read -r line; do
    if echo "$line" | grep -qE "^### $task_id:"; then
      in_task=true
      continue
    fi
    if [ "$in_task" = true ]; then
      if echo "$line" | grep -qE '^### |^## '; then
        break
      fi
      body="${body}${line}"$'\n'
    fi
  done < "$TASKS_FILE"
  
  # Extract metadata from body (only first match)
  TASK_DEPENDS=$(echo "$body" | grep -E '^\*\*Depends:\*\*' | head -1 | sed 's/\*\*Depends:\*\* //' || true)
  TASK_SPEC=$(echo "$body" | grep -E '^\*\*Spec:\*\*' | head -1 | sed 's/\*\*Spec:\*\* //' || true)
  TASK_ARTIFACTS=$(echo "$body" | grep -E '^\*\*Artifacts:\*\*' | head -1 | sed 's/\*\*Artifacts:\*\* //' || true)
  TASK_COMMIT=$(echo "$body" | grep -E '^\*\*Commit:\*\*' | head -1 | sed 's/\*\*Commit:\*\* //' | tr -d '`' || true)
  
  # Description is everything except metadata
  TASK_DESC=$(echo "$body" | grep -v -E '^\*\*(Depends|Spec|Artifacts|Commit|Status|Completed):\*\*' | sed '/^[[:space:]]*$/d')
}

# Get all task IDs from TASKS.md
get_all_task_ids() {
  grep -oE '^### T[0-9a-zA-Z_-]+:' "$TASKS_FILE" 2>/dev/null | sed 's/^### //' | sed 's/:$//'
}

# Check if dependencies are met
deps_met() {
  local deps="$1"
  
  if [ -z "$deps" ] || [ "$deps" = "(none)" ]; then
    return 0
  fi
  
  local done_ids=$(get_done_ids)
  
  # Split deps by comma and check each
  IFS=',' read -ra DEP_ARRAY <<< "$deps"
  for dep in "${DEP_ARRAY[@]}"; do
    dep=$(echo "$dep" | tr -d ' ')
    if ! echo "$done_ids" | grep -q "^${dep}$"; then
      return 1
    fi
  done
  return 0
}

# Find next ready task
find_next_task() {
  local done_ids=$(get_done_ids)
  local in_progress=$(get_in_progress_id)
  
  for task_id in $(get_all_task_ids); do
    # Skip if done
    if echo "$done_ids" | grep -q "^${task_id}$"; then
      continue
    fi
    
    # Skip if in progress
    if [ "$task_id" = "$in_progress" ]; then
      continue
    fi
    
    # Parse task to check deps
    parse_task "$task_id"
    
    # Skip manual tasks
    if echo "$TASK_FLAGS" | grep -q "manual"; then
      continue
    fi
    
    # Check dependencies
    if deps_met "$TASK_DEPENDS"; then
      echo "$task_id"
      return 0
    fi
  done
  
  return 1
}

#######################################
# Prompt Building
#######################################

build_prompt() {
  local prompt="# Task: $TASK_TITLE

$TASK_DESC"
  
  if [ -n "$TASK_SPEC" ]; then
    if [ -f "$TASK_SPEC" ]; then
      prompt="$prompt

## Spec ($TASK_SPEC)
$(cat "$TASK_SPEC")"
    else
      echo -e "${YELLOW}Warning: Spec file not found: $TASK_SPEC${NC}" >&2
    fi
  fi
  
  if [ -n "$TASK_ARTIFACTS" ]; then
    prompt="$prompt

## Expected Artifacts
$TASK_ARTIFACTS"
  fi
  
  if [ -n "$TASK_COMMIT" ]; then
    prompt="$prompt

## When Complete
Commit your changes with message: \`$TASK_COMMIT\`"
  fi
  
  if echo "$TASK_FLAGS" | grep -q "use-subagents"; then
    prompt="$prompt

## Parallelization
This task can be parallelized. Use sub-agents for independent pieces of work."
  fi
  
  echo "$prompt"
}

#######################################
# Agent Running
#######################################

run_agent() {
  local prompt="$1"
  
  if [ "$TASK_AGENT" = "codex" ]; then
    CMD="codex exec"
    $YOLO && CMD="$CMD --dangerously-bypass-approvals-and-sandbox"
    
    # Build prompt with AGENT.md + guardrails context
    TEMP_PROMPT=$(mktemp)
    if [ -f "$AGENT_FILE" ]; then
      cat "$AGENT_FILE" > "$TEMP_PROMPT"
      echo -e "\n---\n" >> "$TEMP_PROMPT"
    fi
    if [ -f ".agent/guardrails.md" ]; then
      cat ".agent/guardrails.md" >> "$TEMP_PROMPT"
      echo -e "\n---\n" >> "$TEMP_PROMPT"
    fi
    echo "$prompt" >> "$TEMP_PROMPT"
    
    echo -e "${MAGENTA}â–¶ Running Codex (non-interactive)${NC}"
    echo ""
    $CMD "$(cat "$TEMP_PROMPT")"
    local exit_code=$?
    rm -f "$TEMP_PROMPT"
    return $exit_code
    
  else
    # Use --print for non-interactive mode
    CMD="claude --print"
    $YOLO && CMD="$CMD --dangerously-skip-permissions"
    
    # Symlink AGENT.md to CLAUDE.md if needed
    if [ -f "$AGENT_FILE" ] && [ ! -f "$PROJECT_DIR/CLAUDE.md" ]; then
      ln -sf AGENT.md "$PROJECT_DIR/CLAUDE.md"
      CREATED_SYMLINK=true
    fi
    
    # Prepend guardrails to prompt if exists
    local full_prompt="$prompt"
    if [ -f ".agent/guardrails.md" ]; then
      full_prompt="$(cat .agent/guardrails.md)

---

$prompt"
    fi
    
    echo -e "${MAGENTA}â–¶ Running Claude Code (non-interactive)${NC}"
    echo ""
    $CMD "$full_prompt"
    local exit_code=$?
    
    [ "$CREATED_SYMLINK" = "true" ] && rm -f "$PROJECT_DIR/CLAUDE.md"
    return $exit_code
  fi
}

#######################################
# TASKS.md In-Place Marking
#######################################

# Mark a task as done in TASKS.md (in-place, don't move)
mark_done_in_tasks() {
  local task_id="$1"
  local commit_hash="$2"
  local timestamp=$(date '+%Y-%m-%d')
  
  # Find the task header and add âœ… if not already there
  if grep -qE "^### $task_id:.*âœ…" "$TASKS_FILE"; then
    return 0  # Already marked
  fi
  
  # Add âœ… and completion info to the header line
  local completion_info="âœ…"
  [ -n "$commit_hash" ] && completion_info="âœ… (done: $timestamp, $commit_hash)"
  
  # Use sed to modify the header line
  sed -i '' "s/^### $task_id: \(.*\)$/### $task_id: \1 $completion_info/" "$TASKS_FILE"
}

#######################################
# Display
#######################################

show_status() {
  init_state
  
  echo -e "${BOLD}Project:${NC} $PROJECT_NAME"
  echo -e "${BOLD}Default agent:${NC} $DEFAULT_AGENT"
  echo ""
  
  # In Progress
  local in_progress=$(get_in_progress_id)
  if [ -n "$in_progress" ]; then
    parse_task "$in_progress"
    echo -e "${YELLOW}â–¶ In Progress:${NC} $TASK_ID: $TASK_TITLE ${CYAN}@$TASK_AGENT${NC}"
  else
    echo -e "${YELLOW}â–¶ In Progress:${NC} (none)"
  fi
  echo ""
  
  # Ready tasks
  echo -e "${GREEN}Ready:${NC}"
  local found_ready=false
  local done_ids=$(get_done_ids)
  
  for task_id in $(get_all_task_ids); do
    # Skip if done
    if echo "$done_ids" | grep -q "^${task_id}$"; then
      continue
    fi
    
    # Skip if in progress
    if [ "$task_id" = "$in_progress" ]; then
      continue
    fi
    
    parse_task "$task_id"
    
    # Skip manual
    if echo "$TASK_FLAGS" | grep -q "manual"; then
      continue
    fi
    
    if deps_met "$TASK_DEPENDS"; then
      echo -e "  â€¢ ${BOLD}$TASK_ID${NC}: $TASK_TITLE ${CYAN}@$TASK_AGENT${NC}"
      found_ready=true
    fi
  done
  
  [ "$found_ready" = false ] && echo "  (none ready - check dependencies)"
  echo ""
  
  # Done count
  local done_count=$(get_done_ids | wc -l | tr -d ' ')
  echo -e "${BLUE}Done:${NC} $done_count tasks"
  
  # Show recent log entries
  if [ -f "$LOG_FILE" ]; then
    local recent=$(tail -5 "$LOG_FILE" 2>/dev/null | grep "^- " | tail -3)
    if [ -n "$recent" ]; then
      echo ""
      echo -e "${DIM}Recent:${NC}"
      echo "$recent" | while read -r line; do
        echo -e "  ${DIM}$line${NC}"
      done
    fi
  fi
}

#######################################
# Commands
#######################################

cmd_init() {
  mkdir -p "$PROJECT_DIR/.agent"
  
  if [ ! -f "$TASKS_FILE" ]; then
    cat > "$TASKS_FILE" << 'EOF'
# Tasks

## ğŸ Milestone 1: MVP

### T1: First task @codex
**Depends:** (none)
**Artifacts:** src/example.ts
**Commit:** `feat: first feature`

Describe what needs to be done here.

---
ğŸ¯ **Milestone 1 complete:** Description of what's achieved
EOF
    echo -e "${GREEN}Created TASKS.md${NC}"
  fi
  
  if [ ! -f "$AGENT_FILE" ]; then
    cat > "$AGENT_FILE" << EOF
# $PROJECT_NAME

Project description here.

## Task Completion Protocol

Before marking any task as complete:
1. Ensure all artifacts exist
2. Run validation (if configured)
3. Commit with the specified message

## Project Structure

Describe key directories and files.

## Conventions

Describe coding conventions.
EOF
    echo -e "${GREEN}Created AGENT.md${NC}"
  fi
  
  if [ ! -f "$CONFIG_FILE" ]; then
    cat > "$CONFIG_FILE" << 'EOF'
# Agent configuration
agent: codex         # Default agent (claude or codex)
yolo: true           # Skip confirmation prompts
validate:            # Command to run before marking done (e.g., pnpm test)
notifications: true  # Desktop notifications on task completion/failure
EOF
    echo -e "${GREEN}Created .agent/config.yml${NC}"
  fi
  
  init_state
  
  if [ ! -f "$LOG_FILE" ]; then
    echo "# Task Log" > "$LOG_FILE"
    echo "" >> "$LOG_FILE"
    echo "Completion history for $PROJECT_NAME" >> "$LOG_FILE"
    echo -e "${GREEN}Created LOG.md${NC}"
  fi
  
  echo -e "${BLUE}Project initialized for next-task v2${NC}"
}

cmd_run() {
  init_state
  
  # Check for in-progress task
  local in_progress=$(get_in_progress_id)
  if [ -n "$in_progress" ]; then
    parse_task "$in_progress"
    echo -e "${YELLOW}Task already in progress:${NC} $TASK_ID: $TASK_TITLE"
    echo "Run 'next done' to complete it, or 'next skip' to skip."
    return 1
  fi
  
  # Find next ready task
  local next_task=$(find_next_task)
  
  if [ -z "$next_task" ]; then
    echo -e "${GREEN}ğŸ‰ All tasks complete (or blocked)!${NC}"
    show_status
    return 0
  fi
  
  # Parse the task
  parse_task "$next_task"
  
  echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo -e "${BOLD}Task:${NC} $TASK_ID: $TASK_TITLE"
  echo -e "${BOLD}Agent:${NC} $TASK_AGENT"
  [ -n "$TASK_SPEC" ] && echo -e "${BOLD}Spec:${NC} $TASK_SPEC"
  [ -n "$TASK_ARTIFACTS" ] && echo -e "${BOLD}Artifacts:${NC} $TASK_ARTIFACTS"
  [ -n "$TASK_COMMIT" ] && echo -e "${BOLD}Commit:${NC} $TASK_COMMIT"
  echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo ""
  
  # Mark in progress
  set_in_progress "$TASK_ID"
  
  # Capture HEAD before agent runs
  local head_before=$(git rev-parse --short HEAD 2>/dev/null || echo "")
  
  # Build prompt and run agent
  local prompt=$(build_prompt)
  run_agent "$prompt"
  local agent_exit=$?
  
  echo ""
  echo -e "${GREEN}Agent finished.${NC}"
  
  # Capture HEAD after agent (agent might have committed)
  local head_after=$(git rev-parse --short HEAD 2>/dev/null || echo "")
  local commit_hash=""
  
  # Did the agent commit?
  if [ "$head_after" != "$head_before" ]; then
    commit_hash="$head_after"
    echo -e "${CYAN}Agent committed: $commit_hash${NC}"
  fi
  
  # Auto-commit if specified AND agent didn't commit
  if [ -n "$TASK_COMMIT" ] && [ -z "$commit_hash" ]; then
    echo ""
    echo -e "${BLUE}Auto-committing:${NC} $TASK_COMMIT"
    git add -A
    if git commit -m "$TASK_COMMIT"; then
      commit_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "")
      echo -e "${GREEN}âœ… Committed ($commit_hash)${NC}"
    else
      echo -e "${YELLOW}No changes to commit${NC}"
    fi
  fi
  
  # Run validation if configured
  if [ -n "$VALIDATE_CMD" ]; then
    echo ""
    echo -e "${BLUE}Running validation:${NC} $VALIDATE_CMD"
    if ! eval "$VALIDATE_CMD"; then
      echo -e "${RED}âŒ Validation failed${NC}"
      echo -e "${DIM}Fix the issues and run 'next done' to complete, or 'next skip' to skip.${NC}"
      return 1
    fi
    echo -e "${GREEN}âœ… Validation passed${NC}"
  fi
  
  # Auto-mark done
  echo ""
  echo -e "${BLUE}Marking task complete...${NC}"
  mark_task_done "$TASK_ID" "$commit_hash"
  mark_done_in_tasks "$TASK_ID" "$commit_hash"
  append_log "$TASK_ID" "$TASK_TITLE" "$commit_hash"
  
  echo -e "${GREEN}âœ… Completed:${NC} $TASK_ID: $TASK_TITLE"
  notify "$TASK_ID complete"
  
  # Log to CTO task-log if available
  if [ -x "$HOME/clawd/scripts/task-log.sh" ]; then
    "$HOME/clawd/scripts/task-log.sh" "$PROJECT_NAME" "$TASK_TITLE" done "next-task,$TASK_AGENT" "$commit_hash" 2>/dev/null && \
      echo -e "${CYAN}ğŸ“ Logged to task-log${NC}"
  fi
  
  echo ""
  show_status
}

cmd_done() {
  init_state
  
  local in_progress=$(get_in_progress_id)
  if [ -z "$in_progress" ]; then
    echo -e "${YELLOW}No task in progress${NC}"
    return 1
  fi
  
  parse_task "$in_progress"
  
  # Run validation if configured
  if [ -n "$VALIDATE_CMD" ]; then
    echo -e "${BLUE}Running validation:${NC} $VALIDATE_CMD"
    if ! eval "$VALIDATE_CMD"; then
      echo -e "${RED}Validation failed. Fix issues before marking done.${NC}"
      return 1
    fi
    echo -e "${GREEN}Validation passed${NC}"
  fi
  
  # Get commit hash - either from auto-commit or current HEAD
  local commit_hash=""
  
  # Try auto-commit if specified and there are changes
  if [ -n "$TASK_COMMIT" ]; then
    git add -A
    if git diff --cached --quiet 2>/dev/null; then
      # No staged changes, use current HEAD
      commit_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "")
      echo -e "${CYAN}Using existing commit: $commit_hash${NC}"
    else
      echo -e "${BLUE}Committing:${NC} $TASK_COMMIT"
      if git commit -m "$TASK_COMMIT"; then
        commit_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "")
        echo -e "${GREEN}Committed ($commit_hash)${NC}"
      fi
    fi
  else
    # No commit message specified, just record current HEAD
    commit_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "")
  fi
  
  # Mark done
  mark_task_done "$TASK_ID" "$commit_hash"
  mark_done_in_tasks "$TASK_ID" "$commit_hash"
  append_log "$TASK_ID" "$TASK_TITLE" "$commit_hash"
  
  echo -e "${GREEN}âœ… Completed:${NC} $TASK_ID: $TASK_TITLE"
  notify "$TASK_ID complete"
  
  # Log to CTO task-log if available
  if [ -x "$HOME/clawd/scripts/task-log.sh" ]; then
    "$HOME/clawd/scripts/task-log.sh" "$PROJECT_NAME" "$TASK_TITLE" done "next-task,$TASK_AGENT" "$commit_hash" 2>/dev/null && \
      echo -e "${CYAN}ğŸ“ Logged to task-log${NC}"
  fi
  
  echo ""
  show_status
}

cmd_skip() {
  init_state
  
  local in_progress=$(get_in_progress_id)
  if [ -z "$in_progress" ]; then
    echo -e "${YELLOW}No task in progress to skip${NC}"
    return 1
  fi
  
  parse_task "$in_progress"
  clear_in_progress
  
  echo -e "${YELLOW}Skipped:${NC} $TASK_ID: $TASK_TITLE"
  echo "Task is still in TASKS.md, will be picked up again when ready."
  echo ""
  show_status
}

cmd_list() {
  if [ -f "$TASKS_FILE" ]; then
    cat "$TASKS_FILE"
  else
    echo "No TASKS.md found"
  fi
}

cmd_log() {
  if [ -f "$LOG_FILE" ]; then
    cat "$LOG_FILE"
  else
    echo "No LOG.md found"
  fi
}

cmd_reset() {
  init_state
  clear_in_progress
  echo -e "${GREEN}Cleared in-progress state${NC}"
  show_status
}

cmd_retry() {
  init_state
  
  local in_progress=$(get_in_progress_id)
  if [ -z "$in_progress" ]; then
    echo -e "${YELLOW}No task in progress to retry${NC}"
    echo -e "${DIM}Use 'next run' to start a new task.${NC}"
    return 1
  fi
  
  parse_task "$in_progress"
  echo -e "${CYAN}Retrying:${NC} $TASK_ID: $TASK_TITLE"
  echo ""
  
  # Clear in-progress so cmd_run picks it up fresh
  clear_in_progress
  
  # Run the task
  cmd_run
}

cmd_commit() {
  local custom_msg="$1"
  
  # Check for changes
  git add -A
  if git diff --cached --quiet 2>/dev/null; then
    echo -e "${YELLOW}Nothing to commit (working tree clean)${NC}"
    return 0
  fi
  
  # Determine commit message
  local commit_msg=""
  
  if [ -n "$custom_msg" ]; then
    # User provided a message
    commit_msg="$custom_msg"
  else
    # Try to get from current task
    init_state
    local in_progress=$(get_in_progress_id)
    if [ -n "$in_progress" ]; then
      parse_task "$in_progress"
      if [ -n "$TASK_COMMIT" ]; then
        commit_msg="$TASK_COMMIT"
        echo -e "${CYAN}Using task commit message: $commit_msg${NC}"
      fi
    fi
  fi
  
  # Fallback to generic message
  if [ -z "$commit_msg" ]; then
    commit_msg="wip: checkpoint"
    echo -e "${DIM}Using default message: $commit_msg${NC}"
  fi
  
  # Commit
  if git commit -m "$commit_msg"; then
    local hash=$(git rev-parse --short HEAD 2>/dev/null || echo "")
    echo -e "${GREEN}âœ… Committed ($hash)${NC}"
    echo ""
    git log --oneline -1
  else
    echo -e "${RED}Commit failed${NC}"
    return 1
  fi
}

cmd_loop() {
  local max_iterations="${1:-0}"
  local push_after="${2:-false}"
  local iteration=0
  local failures=0
  local max_failures=3
  
  init_state
  
  echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo -e "${MAGENTA}ğŸ”„ RALPH MODE: Continuous Loop${NC}"
  [ "$max_iterations" -gt 0 ] && echo -e "${DIM}Max iterations: $max_iterations${NC}"
  echo -e "${DIM}Press Ctrl+C to stop${NC}"
  echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo ""
  
  while true; do
    # Check iteration limit
    if [ "$max_iterations" -gt 0 ] && [ "$iteration" -ge "$max_iterations" ]; then
      echo ""
      echo -e "${GREEN}ğŸ Reached max iterations ($max_iterations)${NC}"
      break
    fi
    
    iteration=$((iteration + 1))
    echo ""
    echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ITERATION $iteration â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    
    # Check for in-progress task (resume it)
    local in_progress=$(get_in_progress_id)
    local task_to_run=""
    
    if [ -n "$in_progress" ]; then
      echo -e "${YELLOW}Resuming in-progress task: $in_progress${NC}"
      task_to_run="$in_progress"
    else
      # Find next ready task
      task_to_run=$(find_next_task)
    fi
    
    if [ -z "$task_to_run" ]; then
      echo -e "${GREEN}ğŸ‰ All tasks complete!${NC}"
      break
    fi
    
    # Parse the task
    parse_task "$task_to_run"
    
    echo -e "${BOLD}Task:${NC} $TASK_ID: $TASK_TITLE"
    echo -e "${BOLD}Agent:${NC} $TASK_AGENT"
    [ -n "$TASK_SPEC" ] && echo -e "${DIM}Spec: $TASK_SPEC${NC}"
    [ -n "$TASK_ARTIFACTS" ] && echo -e "${DIM}Artifacts: $TASK_ARTIFACTS${NC}"
    echo ""
    
    # Mark in progress if not already
    if [ -z "$in_progress" ]; then
      set_in_progress "$TASK_ID"
    fi
    
    # Capture HEAD before agent runs
    local head_before=$(git rev-parse --short HEAD 2>/dev/null || echo "")
    
    # Build prompt and run agent
    local prompt=$(build_prompt)
    run_agent "$prompt"
    local agent_exit=$?
    
    echo ""
    
    # Capture HEAD after agent
    local head_after=$(git rev-parse --short HEAD 2>/dev/null || echo "")
    local commit_hash=""
    
    # Did the agent commit?
    if [ "$head_after" != "$head_before" ]; then
      commit_hash="$head_after"
      echo -e "${CYAN}Agent committed: $commit_hash${NC}"
    fi
    
    # Auto-commit if specified AND agent didn't commit
    if [ -n "$TASK_COMMIT" ] && [ -z "$commit_hash" ]; then
      echo -e "${BLUE}Auto-committing:${NC} $TASK_COMMIT"
      git add -A
      if git commit -m "$TASK_COMMIT"; then
        commit_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "")
        echo -e "${GREEN}Committed ($commit_hash)${NC}"
      fi
    fi
    
    # Check if agent failed (non-zero exit, no commits, no changes)
    if [ "$agent_exit" -ne 0 ] && [ -z "$commit_hash" ]; then
      failures=$((failures + 1))
      echo ""
      echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
      echo -e "${RED}âš ï¸  Task failed (exit code: $agent_exit)${NC}"
      echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
      echo ""
      echo -e "${DIM}Possible causes:${NC}"
      echo -e "${DIM}  â€¢ Agent hit an error or rate limit${NC}"
      echo -e "${DIM}  â€¢ Task description unclear${NC}"
      echo -e "${DIM}  â€¢ Missing dependencies or context${NC}"
      echo ""
      echo -e "${DIM}Check:${NC}"
      echo -e "${DIM}  â€¢ git status (any uncommitted changes?)${NC}"
      echo -e "${DIM}  â€¢ git diff (what did the agent do?)${NC}"
      echo ""
      
      if [ "$failures" -ge "$max_failures" ]; then
        echo -e "${RED}Too many failures ($failures). Stopping loop.${NC}"
        notify "$TASK_ID failed" "next-task âš ï¸"
        echo ""
        echo -e "${CYAN}Next steps:${NC}"
        echo -e "  ${BOLD}next skip${NC}    â€” Skip this task and continue"
        echo -e "  ${BOLD}next reset${NC}   â€” Clear in-progress state"
        echo -e "  ${BOLD}next run${NC}     â€” Try again manually"
        break
      fi
      
      echo -e "${YELLOW}Retrying... (failure $failures/$max_failures)${NC}"
      sleep 2
      continue
    fi
    
    # Run validation if configured
    if [ -n "$VALIDATE_CMD" ]; then
      echo -e "${BLUE}Validating:${NC} $VALIDATE_CMD"
      if ! eval "$VALIDATE_CMD"; then
        failures=$((failures + 1))
        echo -e "${RED}âŒ Validation failed${NC}"
        if [ "$failures" -ge "$max_failures" ]; then
          echo -e "${RED}Too many failures. Stopping loop.${NC}"
          notify "$TASK_ID validation failed" "next-task âš ï¸"
          break
        fi
        echo -e "${YELLOW}Retrying... (failure $failures/$max_failures)${NC}"
        sleep 2
        continue
      fi
      echo -e "${GREEN}âœ… Validation passed${NC}"
    fi
    
    # Success - mark done
    failures=0
    mark_task_done "$TASK_ID" "$commit_hash"
    mark_done_in_tasks "$TASK_ID" "$commit_hash"
    append_log "$TASK_ID" "$TASK_TITLE" "$commit_hash"
    
    echo -e "${GREEN}âœ… Completed:${NC} $TASK_ID: $TASK_TITLE"
    notify "$TASK_ID complete"
    
    # Log to CTO task-log if available
    if [ -x "$HOME/clawd/scripts/task-log.sh" ]; then
      "$HOME/clawd/scripts/task-log.sh" "$PROJECT_NAME" "$TASK_TITLE" done "next-task,$TASK_AGENT" "$commit_hash" 2>/dev/null
    fi
    
    # Optional: push after each iteration
    if [ "$push_after" = "true" ] || [ "$push_after" = "--push" ]; then
      echo -e "${DIM}Pushing...${NC}"
      git push 2>/dev/null || git push -u origin "$(git branch --show-current)" 2>/dev/null
    fi
    
    # Brief pause between iterations
    sleep 1
  done
  
  echo ""
  echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo -e "${MAGENTA}Loop finished after $iteration iterations${NC}"
  echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  show_status
}

cmd_preview() {
  init_state
  
  # Check for in-progress task
  local in_progress=$(get_in_progress_id)
  if [ -n "$in_progress" ]; then
    parse_task "$in_progress"
    echo -e "${YELLOW}Would resume in-progress task:${NC}"
    echo ""
  else
    local next_task=$(find_next_task)
    if [ -z "$next_task" ]; then
      echo -e "${GREEN}Nothing to do â€” all tasks complete (or blocked)${NC}"
      return 0
    fi
    parse_task "$next_task"
    echo -e "${CYAN}Would run next ready task:${NC}"
    echo ""
  fi
  
  echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo -e "${BOLD}Task:${NC}      $TASK_ID: $TASK_TITLE"
  echo -e "${BOLD}Agent:${NC}     $TASK_AGENT"
  [ -n "$TASK_DEPENDS" ] && echo -e "${BOLD}Depends:${NC}   $TASK_DEPENDS"
  [ -n "$TASK_SPEC" ] && echo -e "${BOLD}Spec:${NC}      $TASK_SPEC"
  [ -n "$TASK_ARTIFACTS" ] && echo -e "${BOLD}Artifacts:${NC} $TASK_ARTIFACTS"
  [ -n "$TASK_COMMIT" ] && echo -e "${BOLD}Commit:${NC}    $TASK_COMMIT"
  echo -e "${BOLD}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo ""
  echo -e "${DIM}Description:${NC}"
  echo "$TASK_DESC" | head -20
  echo ""
  echo -e "${DIM}Run 'next' or 'next run' to execute this task.${NC}"
}

cmd_add() {
  # Parse arguments
  local description=""
  local agent="$DEFAULT_AGENT"
  local depends=""
  local commit_prefix="feat"
  
  while [ $# -gt 0 ]; do
    case "$1" in
      @claude)
        agent="claude"
        shift
        ;;
      @codex)
        agent="codex"
        shift
        ;;
      --depends)
        shift
        depends="$1"
        shift
        ;;
      --depends=*)
        depends="${1#--depends=}"
        shift
        ;;
      -*)
        echo -e "${RED}Unknown option: $1${NC}"
        echo "Usage: next add \"Task description\" [@claude|@codex] [--depends T<n>]"
        return 1
        ;;
      *)
        if [ -z "$description" ]; then
          description="$1"
        fi
        shift
        ;;
    esac
  done
  
  # Validate description
  if [ -z "$description" ]; then
    echo -e "${RED}Error: Task description required${NC}"
    echo "Usage: next add \"Task description\" [@claude|@codex] [--depends T<n>]"
    return 1
  fi
  
  # Ensure TASKS.md exists
  if [ ! -f "$TASKS_FILE" ]; then
    echo -e "${RED}Error: TASKS.md not found. Run 'next init' first.${NC}"
    return 1
  fi
  
  # Generate next task ID
  local max_id=0
  for id in $(grep -oE '^### T[0-9]+:' "$TASKS_FILE" 2>/dev/null | grep -oE '[0-9]+'); do
    [ "$id" -gt "$max_id" ] && max_id="$id"
  done
  local next_id=$((max_id + 1))
  local task_id="T$next_id"
  
  # Generate commit message from title
  local title_lower=$(echo "$description" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9 ]//g' | sed 's/  */ /g' | sed 's/ /-/g')
  local commit_msg="$commit_prefix: $title_lower"
  
  # Build task block
  local task_block=""
  
  # Check for template
  local template_file="$PROJECT_DIR/templates/default.md"
  if [ -f "$template_file" ]; then
    # Use template with variable substitution
    task_block=$(cat "$template_file" | \
      sed "s/{{ID}}/$task_id/g" | \
      sed "s/{{TITLE}}/$description/g" | \
      sed "s/{{AGENT}}/$agent/g" | \
      sed "s/{{DEPENDS}}/${depends:-(none)}/g" | \
      sed "s/{{COMMIT_PREFIX}}/$commit_prefix/g" | \
      sed "s/{{TITLE_LOWER}}/$title_lower/g" | \
      sed "s/{{COMMIT}}/$commit_msg/g" | \
      sed '/{{DESCRIPTION}}/d')
  else
    # Default format
    task_block="### $task_id: $description @$agent"
    [ -n "$depends" ] && task_block="$task_block
**Depends:** $depends"
    task_block="$task_block
**Artifacts:** 
**Commit:** \`$commit_msg\`

Describe the task implementation here."
  fi
  
  # Append to TASKS.md
  echo "" >> "$TASKS_FILE"
  echo "$task_block" >> "$TASKS_FILE"
  
  echo -e "${GREEN}âœ… Added task:${NC} $task_id: $description ${CYAN}@$agent${NC}"
  [ -n "$depends" ] && echo -e "${DIM}   Depends: $depends${NC}"
  echo -e "${DIM}   Commit: $commit_msg${NC}"
}

cmd_help() {
  echo "next-task v2: Task queue runner for AI coding agents"
  echo ""
  echo "Usage: next [command]"
  echo ""
  echo "Commands:"
  echo "  (default)  Run next ready task (single task, then stop)"
  echo "  add        â• Add a new task to TASKS.md"
  echo "  loop       ğŸ”„ Ralph mode: run tasks continuously until done"
  echo "  preview    ğŸ‘€ Dry run: show what would happen"
  echo "  status     Show task status"
  echo "  done       Mark current task complete (manual mode)"
  echo "  commit     Commit changes (uses task message or custom)"
  echo "  skip       Skip current task"
  echo "  retry      Retry the in-progress task"
  echo "  list       Show TASKS.md"
  echo "  log        Show LOG.md"
  echo "  reset      Clear in-progress state"
  echo "  init       Initialize project"
  echo "  help       Show this help"
  echo ""
  echo "Examples:"
  echo "  next                     # Run one task"
  echo "  next add \"Task name\" @claude  # Add task for Claude"
  echo "  next add \"Task\" --depends T5  # Add task with dependency"
  echo "  next loop                # Run all tasks continuously (Ctrl+C to stop)"
  echo "  next loop 10             # Run max 10 iterations"
  echo "  next loop 0 --push       # Unlimited, push after each task"
  echo "  next commit 'my message' # Commit with custom message"
  echo ""
  echo "State is stored in .agent/state.json"
  echo "Completion log is in LOG.md"
}

#######################################
# Main
#######################################

load_config

case "${1:-run}" in
  init)     cmd_init ;;
  status|s) init_state; show_status ;;
  done|d)   cmd_done ;;
  skip)     cmd_skip ;;
  list|l)   cmd_list ;;
  log)      cmd_log ;;
  reset)    cmd_reset ;;
  retry|r)  cmd_retry ;;
  commit|c) cmd_commit "$2" ;;
  loop)     cmd_loop "$2" "$3" ;;
  preview|p) cmd_preview ;;
  add|a)    shift; cmd_add "$@" ;;
  run|"")   cmd_run ;;
  help|--help|-h) cmd_help ;;
  *)
    echo "Unknown command: $1"
    cmd_help
    exit 1
    ;;
esac
